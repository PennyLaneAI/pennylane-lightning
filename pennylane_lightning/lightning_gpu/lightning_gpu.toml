schema = 2

# The union of all gate types listed in this section must match what
# the device considers "supported" through PennyLane's device API.
[operators.gates.native]

Identity               = {}
PauliX                 = {}
PauliY                 = {}
PauliZ                 = {}
Hadamard               = {}
S                      = {}
T                      = {}
PhaseShift             = {}
RX                     = {}
RY                     = {}
RZ                     = {}
Rot                    = {}
CNOT                   = {}
CY                     = {}
CZ                     = {}
SWAP                   = {}
CSWAP                  = {}
Toffoli                = {}
IsingXX                = {}
IsingXY                = {}
IsingYY                = {}
IsingZZ                = {}
ControlledPhaseShift   = {}
CRX                    = {}
CRY                    = {}
CRZ                    = {}
CRot                   = {}
SingleExcitation       = {}
SingleExcitationPlus   = {}
SingleExcitationMinus  = {}
DoubleExcitation       = {}
DoubleExcitationPlus   = {}
DoubleExcitationMinus  = {}
MultiRZ                = {}
QubitUnitary           = {}
GlobalPhase            = {}

# Operators that should be decomposed according to the algorithm used
# by PennyLane's device API.
# Optional, since gates not listed in this list will typically be decomposed by
# default, but can be useful to express a deviation from this device's regular
# strategy in PennyLane.
[operators.gates.decomp]

BasisState             = {}
QFT                    = {}
QubitStateVector       = {}
StatePrep              = {}
MultiControlledX       = {}

# Gates which should be translated to QubitUnitary
[operators.gates.matrix]


ControlledQubitUnitary = {}
ECR                    = {}
SX                     = {}
ISWAP                  = {}
PSWAP                  = {}
SISWAP                 = {}
SQISW                  = {}
CPhase                 = {}
OrbitalRotation        = {}
QubitCarry             = {}
QubitSum               = {}
DiagonalQubitUnitary   = {}
BlockEncode            = {}

# Observables supported by the device
[operators.observables]

Identity               = {}
PauliX                 = {}
PauliY                 = {}
PauliZ                 = {}
Hadamard               = {}
Hermitian              = {}
Hamiltonian            = {}
SparseHamiltonian      = {}

[measurement_processes]

Expval                 = {}
Var                    = {}
Probs                  = {}
State                  = { condition = [ "analytic" ] }
Sample                 = { condition = [ "finiteshots" ] }
Count                  = { condition = [ "finiteshots" ] }

[compilation]
# If the device is compatible with qjit
qjit_compatible = false
# If the device requires run time generation of the quantum circuit.
runtime_code_generation = false
# If the device supports mid circuit measurements natively
mid_circuit_measurement = false

# This field is currently unchecked but it is reserved for the purpose of
# determining if the device supports dynamic qubit allocation/deallocation.
dynamic_qubit_management = false
